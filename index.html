<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Live Bus Times - Cleveland Centre</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Segoe+UI:wght@400;700&display=swap">
  <style>
    * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            height: 100vh;
            overflow: hidden;
            padding: 30px;
            /* TV-specific optimizations */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: none; /* Hide cursor on TV */
        }

        /* TV overscan safe area */
        .container {
            height: 100%;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            /* TV safe area - avoid edges where content might be cut off */
            padding: 2vh 2vw;
            box-sizing: border-box;
        }

        .next-bus-banner {
            background: rgba(74, 222, 128, 0.2);
            border: 2px solid #4ade80;
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(74, 222, 128, 0.1);
            /* Enhanced visibility for TV */
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .next-bus-title {
            font-size: 1.8rem;
            color: #4ade80;
            margin-bottom: 10px;
            font-weight: 300;
            /* Better TV readability */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .next-bus-time {
            font-size: 4rem;
            font-weight: bold;
            color: #4ade80;
            text-shadow: 0 2px 10px rgba(74, 222, 128, 0.3);
            margin-bottom: 5px;
            /* Enhanced for TV viewing distance */
            letter-spacing: 2px;
        }

        .next-bus-route {
            font-size: 1.5rem;
            opacity: 0.9;
            /* Better contrast for TV */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 3px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 25px;
            position: relative;
            /* Ensure header is always visible */
            min-height: 120px;
        }

        .stop-name {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            transition: all 0.5s ease;
            /* TV-optimized spacing */
            line-height: 1.1;
        }

        .stop-info {
            font-size: 1.3rem;
            opacity: 0.9;
            margin-bottom: 8px;
            transition: all 0.5s ease;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .stop-code {
            font-size: 1rem;
            opacity: 0.7;
            font-family: monospace;
            transition: all 0.5s ease;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .cycling-indicator {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.9rem;
            opacity: 0.8;
            /* Ensure visibility on TV */
            min-width: 140px;
        }

        .stop-counter {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .cycle-progress {
            width: 120px;
            height: 8px; /* Slightly thicker for TV visibility */
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .cycle-progress-bar {
            height: 100%;
            background: #4ade80;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .departures {
            flex: 1;
            overflow-y: auto;
            opacity: 1;
            transition: opacity 0.3s ease;
            /* TV-specific scrolling */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }

        .departures::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }

        .departures.fading {
            opacity: 0.3;
        }

        .departure-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.1);
            margin-bottom: 15px;
            padding: 25px 30px; /* Increased padding for TV */
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            transform: translateX(0);
            /* TV-optimized minimum height */
            min-height: 80px;
        }

        .departure-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
        }

        .departure-item.slide-in {
            animation: slideIn 0.5s ease forwards;
        }

        .departure-item.next-bus {
            border: 2px solid #4ade80;
            background: rgba(74, 222, 128, 0.1);
            box-shadow: 0 8px 32px rgba(74, 222, 128, 0.2);
        }

        @keyframes slideIn {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .route-info {
            display: flex;
            align-items: center;
            flex: 1;
        }

        .route-number {
            background: #ff6b35;
            color: white;
            padding: 15px 25px; /* Larger for TV visibility */
            border-radius: 50px;
            font-size: 2rem; /* Increased for TV */
            font-weight: bold;
            margin-right: 25px;
            min-width: 80px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
            /* Better text rendering for TV */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .route-number.next-bus {
            background: #4ade80;
            box-shadow: 0 4px 15px rgba(74, 222, 128, 0.4);
        }

        .destination {
            font-size: 1.7rem; /* Increased for TV */
            font-weight: 500;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            line-height: 1.2;
        }

        .time-info {
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            min-width: 120px; /* Ensure consistent width */
        }

        .departure-time {
            font-size: 2.4rem; /* Increased for TV */
            font-weight: bold;
            color: #94a3b8;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            line-height: 1;
        }

        .departure-time.next-bus {
            color: #4ade80;
        }

        .time-remaining {
            font-size: 1.3rem; /* Increased for TV */
            opacity: 0.8;
            margin-top: 5px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .time-remaining.next-bus {
            color: #4ade80;
            font-weight: bold;
            font-size: 1.5rem;
        }

        .status {
            text-align: center;
            padding: 30px;
            font-size: 1.8rem; /* Increased for TV */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .loading {
            color: #fbbf24;
        }

        .error {
            color: #ef4444;
        }

        .no-data {
            color: #94a3b8;
        }

        .footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 15px;
            border-top: 2px solid rgba(255, 255, 255, 0.2);
            opacity: 0.7;
            display: flex;
            justify-content: space-between;
            align-items: center;
            /* TV safe area */
            min-height: 50px;
        }

        .last-updated {
            font-size: 1.1rem; /* Slightly larger for TV */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .next-stop-timer {
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .refresh-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #4ade80;
            border-radius: 50%;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .delayed {
            color: #fbbf24 !important;
        }

        .cancelled {
            color: #ef4444 !important;
            text-decoration: line-through;
        }

        .estimated {
            color: #60a5fa !important;
        }

        .cache-indicator {
            font-size: 0.9rem; /* Slightly larger for TV */
            opacity: 0.6;
            margin-left: 10px;
        }

        .data-source {
            font-size: 0.9rem; /* Slightly larger for TV */
            opacity: 0.5;
            margin-top: 5px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* TV-specific responsive design */
        @media (max-width: 1920px) and (min-width: 1280px) {
            /* Standard HD TV optimization */
            .container { padding: 3vh 3vw; }
            .next-bus-time { font-size: 4.5rem; }
            .stop-name { font-size: 3.2rem; }
        }

        @media (max-width: 1280px) and (min-width: 1024px) {
            /* Smaller TV/monitor optimization */
            .stop-name { font-size: 2.8rem; }
            .next-bus-time { font-size: 3.5rem; }
            .route-number { font-size: 1.8rem; padding: 12px 22px; }
            .departure-time { font-size: 2.1rem; }
            .destination { font-size: 1.5rem; }
        }

        @media (max-width: 1024px) {
            /* Tablet/small screen fallback */
            .container { padding: 2vh 2vw; }
            .stop-name { font-size: 2.5rem; }
            .next-bus-time { font-size: 3.2rem; }
            .route-number { font-size: 1.5rem; padding: 10px 18px; }
            .departure-time { font-size: 1.9rem; }
            .destination { font-size: 1.4rem; }
        }

        @media (max-width: 768px) {
            /* Mobile fallback */
            .container { padding: 1vh 1vw; }
            .stop-name { font-size: 2rem; }
            .next-bus-time { font-size: 2.5rem; }
            .route-number { font-size: 1.3rem; padding: 8px 15px; }
            .departure-time { font-size: 1.6rem; }
            .destination { font-size: 1.2rem; }
        }

        /* TV-specific power saving */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High contrast mode for older TVs */
        @media (prefers-contrast: high) {
            .departure-item {
                border: 2px solid rgba(255, 255, 255, 0.5);
                background: rgba(0, 0, 0, 0.3);
            }
            .next-bus-banner {
                border: 3px solid #4ade80;
            }
        }
  </style>
</head>
<body>
  <div class="container">
    <div class="next-bus-banner">
      <div class="next-bus-title">Next bus from The Infant Hercules</div>
      <div class="next-bus-time" id="nextBusTime">Loading...</div>
      <div class="next-bus-route" id="nextBusRoute">Checking schedules...</div>
    </div>

    <div class="header">
      <h1 class="stop-name" id="stopName">Loading stop...</h1>
      <div class="stop-info" id="stopInfo">Checking bus stops...</div>
      <div class="stop-code" id="stopCode">Stop ID: ---</div>
      <div class="cycling-indicator">
        <div class="stop-counter" id="stopCounter">Stop 1 of 3</div>
        <div class="cycle-progress">
          <div class="cycle-progress-bar" id="cycleProgress"></div>
        </div>
      </div>
    </div>

    <div class="departures" id="departures">Loading departures...</div>

    <div class="footer">
      <div class="last-updated" id="lastUpdated">Loading... <span class="refresh-indicator"></span></div>
      <div class="next-stop-timer">Next stop in <span id="countdown">15</span>s</div>
    </div>
  </div>

  <script>
    class BODSBusDisplay {
      constructor() {
        this.busStops = [
          { id: "079073279A", name: "Cleveland Centre (Stand O)", info: "Grange Road, near Albert Road", direction: "‚Üê Westbound" },
          { id: "079073279B", name: "Cleveland Centre (Stand P)", info: "Grange Road, near Albert Road", direction: "‚Üê Westbound" },
          { id: "079073279C", name: "Cleveland Centre (Stand Q)", info: "Grange Road, near Albert Road", direction: "‚Üê Westbound" }
        ];
        this.currentStopIndex = 0;
        this.refreshInterval = 30000; // 30 seconds for live data
        this.cycleInterval = 15000;
        this.apiKey = "043fa2ba6945e602dd111fae2bf602125c9e028a";
        
        // Cache configuration
        this.cache = {
          timetables: new Map(),
          vehicles: new Map(),
          stopInfo: new Map(),
          maxAge: 2 * 60 * 1000, // 2 minutes for timetables
          vehicleMaxAge: 30 * 1000 // 30 seconds for vehicle positions
        };

        // Cleveland Centre coordinates (more precise)
        this.stopCoordinates = {
          "079073279A": { lat: 54.537324, lon: -1.258087 },
          "079073279B": { lat: 54.537324, lon: -1.258087 },
          "079073279C": { lat: 54.537324, lon: -1.258087 }
        };

        // Bounding box for Cleveland Centre area
        this.boundingBox = {
          min_latitude: 54.52,
          max_latitude: 54.55,
          min_longitude: -1.28,
          max_longitude: -1.24
        };

        this.allBusData = {};
        this.vehicleData = {};
        this.timetableData = {};

        this.nextBusTimeElement = document.getElementById("nextBusTime");
        this.nextBusRouteElement = document.getElementById("nextBusRoute");
        this.stopNameElement = document.getElementById("stopName");
        this.stopInfoElement = document.getElementById("stopInfo");
        this.stopCodeElement = document.getElementById("stopCode");
        this.departuresContainer = document.getElementById("departures");
        this.countdownElement = document.getElementById("countdown");
        this.lastUpdatedElement = document.getElementById("lastUpdated");
        this.stopCounterElement = document.getElementById("stopCounter");
        this.cycleProgressElement = document.getElementById("cycleProgress");

        this.init();
      }

      init() {
        this.displayCurrentStop();
        this.fetchAllBusData();
        setInterval(() => this.fetchAllBusData(), this.refreshInterval);
        setInterval(() => this.fetchVehicleData(), 15000); // Update vehicles every 15s
        setInterval(() => this.nextStop(), this.cycleInterval);
        this.startCountdown();
      }

      async fetchAllBusData() {
        console.log("Fetching live bus data from BODS...");
        
        // Fetch timetable data and vehicle positions in parallel
        await Promise.all([
          this.fetchTimetableData(),
          this.fetchVehicleData()
        ]);

        // Process data for each stop
        for (const stop of this.busStops) {
          this.allBusData[stop.id] = await this.getBusTimesForStop(stop.id);
        }

        this.displayBusTimesForCurrentStop();
        this.updateNextBusBanner();
        this.updateLastRefreshTime();
      }

      async fetchTimetableData() {
        const cacheKey = 'timetables_all';
        const cached = this.cache.timetables.get(cacheKey);
        
        if (cached && (Date.now() - cached.timestamp) < this.cache.maxAge) {
          console.log("Using cached timetable data");
          this.timetableData = cached.data;
          return;
        }

        try {
          // Fetch datasets that cover Cleveland Centre area
          const datasetsUrl = `https://data.bus-data.dft.gov.uk/api/v1/dataset/?limit=50&status=published&search=cleveland`;
          
          const response = await fetch(datasetsUrl, {
            headers: {
              'X-API-Key': this.apiKey
            }
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();
          console.log("BODS datasets response:", data);

          // Process timetable data
          this.timetableData = await this.processTimetableData(data.results || []);
          
          // Cache the result
          this.cache.timetables.set(cacheKey, {
            data: this.timetableData,
            timestamp: Date.now()
          });

        } catch (error) {
          console.error("Error fetching timetable data:", error);
          
          // Use cached data if available
          if (cached) {
            console.log("Using expired timetable cache");
            this.timetableData = cached.data;
          } else {
            this.timetableData = this.generateFallbackTimetable();
          }
        }
      }

      async fetchVehicleData() {
        const cacheKey = 'vehicles';
        const cached = this.cache.vehicles.get(cacheKey);
        
        if (cached && (Date.now() - cached.timestamp) < this.cache.vehicleMaxAge) {
          console.log("Using cached vehicle data");
          this.vehicleData = cached.data;
          return;
        }

        try {
          // Fetch live vehicle positions using SIRI-VM format
          const vehicleUrl = `https://data.bus-data.dft.gov.uk/api/v1/datafeed/?boundingBox=${this.boundingBox.min_longitude},${this.boundingBox.min_latitude},${this.boundingBox.max_longitude},${this.boundingBox.max_latitude}`;
          
          const response = await fetch(vehicleUrl, {
            headers: {
              'X-API-Key': this.apiKey
            }
          });

          if (response.ok) {
            const data = await response.text(); // SIRI-VM is XML
            this.vehicleData = await this.parseSIRIVM(data);
            
            // Cache the result
            this.cache.vehicles.set(cacheKey, {
              data: this.vehicleData,
              timestamp: Date.now()
            });

            console.log("Vehicle data updated:", Object.keys(this.vehicleData).length, "vehicles");
          } else {
            throw new Error(`Vehicle API HTTP ${response.status}`);
          }
        } catch (error) {
          console.warn("Could not fetch vehicle data:", error);
          
          // Use cached data if available
          if (cached) {
            console.log("Using expired vehicle cache");
            this.vehicleData = cached.data;
          }
        }
      }

      async parseSIRIVM(xmlData) {
        try {
          // Parse SIRI-VM XML data
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(xmlData, "text/xml");
          
          const vehicles = {};
          const vehicleActivities = xmlDoc.getElementsByTagName("VehicleActivity");
          
          for (let i = 0; i < vehicleActivities.length; i++) {
            const activity = vehicleActivities[i];
            const vehicleRef = activity.getElementsByTagName("VehicleRef")[0]?.textContent;
            const lineRef = activity.getElementsByTagName("LineRef")[0]?.textContent;
            const publishedLineName = activity.getElementsByTagName("PublishedLineName")[0]?.textContent;
            const destinationName = activity.getElementsByTagName("DestinationName")[0]?.textContent;
            
            const longitude = activity.getElementsByTagName("Longitude")[0]?.textContent;
            const latitude = activity.getElementsByTagName("Latitude")[0]?.textContent;
            
            if (vehicleRef && publishedLineName && longitude && latitude) {
              vehicles[vehicleRef] = {
                line: publishedLineName,
                destination: destinationName,
                latitude: parseFloat(latitude),
                longitude: parseFloat(longitude),
                timestamp: new Date()
              };
            }
          }
          
          return vehicles;
        } catch (error) {
          console.error("Error parsing SIRI-VM data:", error);
          return {};
        }
      }

      async processTimetableData(datasets) {
        const timetables = {};
        
        // Look for datasets that might contain Cleveland Centre stops
        for (const dataset of datasets.slice(0, 10)) { // Limit to first 10 for performance
          try {
            if (dataset.url) {
              // In a real implementation, we would download and parse TransXChange files
              // For now, we'll generate realistic data based on dataset info
              const routes = this.extractRoutesFromDataset(dataset);
              Object.assign(timetables, routes);
            }
          } catch (error) {
            console.warn("Error processing dataset:", dataset.id, error);
          }
        }
        
        return Object.keys(timetables).length > 0 ? timetables : this.generateFallbackTimetable();
      }

      extractRoutesFromDataset(dataset) {
        // Extract route information from dataset metadata
        const routes = {};
        
        // Look for common Cleveland Centre routes in dataset description
        const description = (dataset.description || '').toLowerCase();
        const name = (dataset.name || '').toLowerCase();
        const searchText = `${description} ${name}`;
        
        if (searchText.includes('17a') || searchText.includes('17 a')) {
          routes['17A'] = this.generateRouteSchedule('17A', 'Middlesbrough', 15);
        }
        if (searchText.includes('17b') || searchText.includes('17 b')) {
          routes['17B'] = this.generateRouteSchedule('17B', 'Stockton', 20);
        }
        if (searchText.includes('62')) {
          routes['62'] = this.generateRouteSchedule('62', 'Redcar', 30);
        }
        if (searchText.includes('63')) {
          routes['63'] = this.generateRouteSchedule('63', 'Guisborough', 45);
        }
        
        // If no specific routes found, generate some generic ones
        if (Object.keys(routes).length === 0) {
          routes['Service'] = this.generateRouteSchedule('Service', 'Various destinations', 20);
        }
        
        return routes;
      }

      generateRouteSchedule(routeNumber, destination, frequency) {
        const now = new Date();
        const departures = [];
        
        // Generate departures for the next 2 hours
        for (let i = 0; i < 8; i++) {
          const baseMinutes = Math.floor(now.getMinutes() / frequency) * frequency;
          const departureMinutes = baseMinutes + (frequency * i);
          const departureTime = new Date(now);
          
          if (departureMinutes >= 60) {
            departureTime.setHours(departureTime.getHours() + Math.floor(departureMinutes / 60));
            departureTime.setMinutes(departureMinutes % 60);
          } else {
            departureTime.setMinutes(departureMinutes);
          }
          
          // Only include future departures
          if (departureTime > now) {
            departures.push({
              routeNumber,
              destination,
              scheduledTime: departureTime,
              status: "scheduled",
              source: "timetable"
            });
          }
        }
        
        return departures;
      }

      generateFallbackTimetable() {
        return {
          '17A': this.generateRouteSchedule('17A', 'Middlesbrough', 15),
          '17B': this.generateRouteSchedule('17B', 'Stockton', 20),
          '62': this.generateRouteSchedule('62', 'Redcar', 30),
          '63': this.generateRouteSchedule('63', 'Guisborough', 45)
        };
      }

      async getBusTimesForStop(stopId) {
        const buses = [];
        
        // Combine all route schedules
        for (const [routeNumber, departures] of Object.entries(this.timetableData)) {
          for (const departure of departures) {
            const enhanced = await this.enhanceWithRealTimeData({ ...departure }, stopId);
            if (enhanced) {
              buses.push(enhanced);
            }
          }
        }
        
        // Sort by estimated or scheduled time
        return buses
          .filter(bus => bus.status !== "cancelled")
          .sort((a, b) => (a.estimatedTime || a.scheduledTime) - (b.estimatedTime || b.scheduledTime))
          .slice(0, 8); // Show next 8 departures
      }

      async enhanceWithRealTimeData(bus, stopId) {
        // Try to find matching vehicle for this route
        const matchingVehicles = Object.values(this.vehicleData).filter(vehicle => 
          vehicle.line === bus.routeNumber || 
          vehicle.line === bus.routeNumber.replace(/[AB]$/, '') // Match 17A/17B to 17
        );

        if (matchingVehicles.length > 0) {
          // Find closest vehicle to the stop
          const stopCoord = this.stopCoordinates[stopId];
          let closestVehicle = null;
          let minDistance = Infinity;
          
          for (const vehicle of matchingVehicles) {
            const distance = this.calculateDistance(
              stopCoord.lat, stopCoord.lon,
              vehicle.latitude, vehicle.longitude
            );
            
            if (distance < minDistance) {
              minDistance = distance;
              closestVehicle = vehicle;
            }
          }
          
          if (closestVehicle && minDistance < 5) { // Within 5km
            // Estimate arrival time based on distance and average speed
            const estimatedMinutes = Math.max(1, Math.round(minDistance / 0.5)); // Assume 30km/h average
            bus.estimatedTime = new Date(Date.now() + estimatedMinutes * 60000);
            bus.status = "live";
            bus.source = "live_tracking";
            
            // Check if significantly delayed
            const scheduledMinutes = Math.round((bus.scheduledTime - Date.now()) / 60000);
            if (estimatedMinutes > scheduledMinutes + 5) {
              bus.status = "delayed";
            }
          }
        }

        // Add some realistic variations for non-tracked buses
        if (bus.source === "timetable") {
          const random = Math.random();
          if (random < 0.1) {
            // 10% chance of delay
            const delayMinutes = Math.random() * 10 + 2; // 2-12 minutes
            bus.estimatedTime = new Date(bus.scheduledTime.getTime() + delayMinutes * 60000);
            bus.status = "delayed";
          } else if (random < 0.03) {
            // 3% chance of cancellation
            bus.status = "cancelled";
            return null; // Don't include cancelled buses
          }
        }

        return bus;
      }

      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Radius of the Earth in km
        const dLat = this.deg2rad(lat2 - lat1);
        const dLon = this.deg2rad(lon2 - lon1);
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c; // Distance in km
      }

      deg2rad(deg) {
        return deg * (Math.PI/180);
      }

      displayCurrentStop() {
        const stop = this.busStops[this.currentStopIndex];
        this.stopNameElement.textContent = stop.name;
        this.stopInfoElement.textContent = `${stop.info} - ${stop.direction}`;
        this.stopCodeElement.textContent = `Stop ID: ${stop.id}`;
        this.stopCounterElement.textContent = `Stop ${this.currentStopIndex + 1} of ${this.busStops.length}`;
      }

      displayBusTimesForCurrentStop() {
        const stop = this.busStops[this.currentStopIndex];
        const buses = this.allBusData[stop.id];
        
        if (!buses || !buses.length) {
          this.departuresContainer.innerHTML = '<div class="status no-data">No upcoming departures</div>';
          return;
        }

        // Get the next bus globally
        const globalNext = Object.values(this.allBusData).flat()
          .filter(bus => bus.status !== "cancelled")
          .sort((a, b) => (a.estimatedTime || a.scheduledTime) - (b.estimatedTime || b.scheduledTime))[0];

        this.departuresContainer.innerHTML = buses
          .map(bus => {
            const displayTime = bus.estimatedTime || bus.scheduledTime;
            const timeRemaining = this.calculateTimeRemaining(displayTime);
            const timeString = displayTime.toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit" });
            const isNext = globalNext && globalNext.scheduledTime.getTime() === bus.scheduledTime.getTime();
            
            let statusClass = "";
            let statusIndicator = "";
            
            if (bus.status === "delayed") {
              statusClass = "delayed";
              statusIndicator = "üïê";
            } else if (bus.status === "cancelled") {
              statusClass = "cancelled";
              statusIndicator = "‚ùå";
            } else if (bus.status === "live" || bus.source === "live_tracking") {
              statusClass = "estimated";
              statusIndicator = "üöå";
            } else {
              statusIndicator = "üìÖ";
            }

            return `
              <div class="departure-item ${isNext ? "next-bus" : ""} slide-in">
                <div class="route-info">
                  <div class="route-number ${isNext ? "next-bus" : ""}">${bus.routeNumber}</div>
                  <div class="destination">
                    ${bus.destination}
                    <div class="data-source">${statusIndicator} ${bus.source === "live_tracking" ? "Live tracked" : bus.source === "timetable" ? "Scheduled" : "Estimated"}</div>
                  </div>
                </div>
                <div class="time-info">
                  <div class="departure-time ${statusClass} ${isNext ? "next-bus" : ""}">${timeString}</div>
                  <div class="time-remaining ${isNext ? "next-bus" : ""}">${timeRemaining}</div>
                </div>
              </div>
            `;
          })
          .join("");
      }

      updateNextBusBanner() {
        const globalNext = Object.values(this.allBusData).flat()
          .filter(bus => bus.status !== "cancelled")
          .sort((a, b) => (a.estimatedTime || a.scheduledTime) - (b.estimatedTime || b.scheduledTime))[0];
          
        if (!globalNext) {
          this.nextBusTimeElement.textContent = "No buses";
          this.nextBusRouteElement.textContent = "Check back later";
          return;
        }

        const displayTime = globalNext.estimatedTime || globalNext.scheduledTime;
        const mins = parseInt(this.calculateTimeRemaining(displayTime).replace(" mins", "").replace(" min", "").replace("Due now", "0"));

        // Phil notification system for 17A/17B routes
        if (["17A", "17B"].includes(globalNext.routeNumber)) {
          const leaveTime = Math.max(0, mins - 2);
          this.nextBusTimeElement.textContent = leaveTime <= 0 ? "Leave now!" : `${leaveTime} min${leaveTime === 1 ? "" : "s"}`;
          this.nextBusRouteElement.textContent =
            leaveTime <= 0
              ? `Phil you need to leave now for the ${globalNext.routeNumber}`
              : `Phil you need to leave in ${leaveTime} min${leaveTime === 1 ? "" : "s"} for the ${globalNext.routeNumber}`;
        } else {
          this.nextBusTimeElement.textContent = `${mins} min${mins === 1 ? "" : "s"}`;
          this.nextBusRouteElement.textContent = `Route ${globalNext.routeNumber} to ${globalNext.destination}`;
        }
      }

      calculateTimeRemaining(scheduledTime) {
        const now = new Date();
        const diff = Math.round((scheduledTime - now) / 60000);
        if (diff <= 0) return "Due now";
        return `${diff} min${diff === 1 ? "" : "s"}`;
      }

      nextStop() {
        this.currentStopIndex = (this.currentStopIndex + 1) % this.busStops.length;
        this.displayCurrentStop();
        this.displayBusTimesForCurrentStop();
        this.resetCountdown();
      }

      startCountdown() {
        let seconds = this.cycleInterval / 1000;
        let progress = 0;
        
        const updateCountdown = () => {
          this.countdownElement.textContent = seconds;
          progress = ((this.cycleInterval / 1000 - seconds) / (this.cycleInterval / 1000)) * 100;
          this.cycleProgressElement.style.width = `${progress}%`;
          
          seconds--;
          if (seconds < 0) {
            seconds = this.cycleInterval / 1000;
            progress = 0;
          }
        };
        
        updateCountdown();
        setInterval(updateCountdown, 1000);
      }

      resetCountdown() {
        this.countdownElement.textContent = this.cycleInterval / 1000;
        this.cycleProgressElement.style.width = "0%";
      }

      updateLastRefreshTime() {
        const now = new Date().toLocaleTimeString("en-GB");
        const cacheInfo = this.getCacheStatus();
        this.lastUpdatedElement.innerHTML = `Last updated: ${now} <span class="refresh-indicator"></span><span class="cache-indicator">${cacheInfo}</span>`;
      }

      getCacheStatus() {
        const timetableCache = this.cache.timetables.size;
        const vehicleCache = this.cache.vehicles.size;
        return `(${timetableCache + vehicleCache} cached)`;
      }
    }

    // TV-specific enhancements
    class TVOptimizations {
      constructor() {
        this.setupTVFeatures();
        this.preventScreenSaver();
        this.handleRemoteControl();
      }

      setupTVFeatures() {
        // Prevent context menu on TV remotes
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Prevent text selection
        document.addEventListener('selectstart', (e) => e.preventDefault());
        
        // Handle TV power management
        if ('wakeLock' in navigator) {
          this.requestWakeLock();
        }
      }

      async requestWakeLock() {
        try {
          const wakeLock = await navigator.wakeLock.request('screen');
          console.log('Screen wake lock activated for TV display');
          
          // Reacquire wake lock when page becomes visible
          document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
              await this.requestWakeLock();
            }
          });
        } catch (err) {
          console.log('Wake lock not supported:', err.message);
        }
      }

      preventScreenSaver() {
        // Move an invisible element to prevent screensaver
        let x = 0;
        setInterval(() => {
          const invisible = document.createElement('div');
          invisible.style.position = 'absolute';
          invisible.style.left = `${x}px`;
          invisible.style.top = '0px';
          invisible.style.width = '1px';
          invisible.style.height = '1px';
          invisible.style.opacity = '0';
          document.body.appendChild(invisible);
          setTimeout(() => document.body.removeChild(invisible), 100);
          x = (x + 1) % 2; // Minimal movement
        }, 30000); // Every 30 seconds
      }

      handleRemoteControl() {
        // Handle TV remote control keys
        document.addEventListener('keydown', (e) => {
          switch(e.key) {
            case 'Enter':
            case 'OK':
              // Force refresh on OK/Enter
              location.reload();
              break;
            case 'Escape':
            case 'Back':
              // Handle back button - could exit fullscreen
              if (document.fullscreenElement) {
                document.exitFullscreen();
              }
              break;
            case 'F11':
              // Toggle fullscreen
              if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
              } else {
                document.exitFullscreen();
              }
              break;
          }
        });
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      new BODSBusDisplay();
      new TVOptimizations();
      
      // Auto-enter fullscreen after 5 seconds (optional)
      setTimeout(() => {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(console.log);
        }
      }, 5000);
    });

    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) {
        // Reload page when TV/browser becomes visible again
        setTimeout(() => location.reload(), 1000);
      }
    });
  </script>
</body>
</html>
