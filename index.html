<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Live Bus Times - The Infant Hercules</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: Arial, sans-serif; /* Fire Stick friendly font */
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      color: white;
      height: 100vh;
      overflow: hidden;
      padding: 20px;
      cursor: none;
    }

    /* Fire Stick / Amazon Silk optimizations */
    .fire-stick-mode {
      font-family: Arial, sans-serif !important;
      background: #1e3c72 !important; /* Solid color for Fire Stick */
    }

    .fire-stick-mode * {
      -webkit-transform: translateZ(0); /* Hardware acceleration */
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }

    .fire-stick-mode .next-bus-banner,
    .fire-stick-mode .departure-item {
      backdrop-filter: none !important; /* Remove blur effects */
      background: rgba(0, 0, 0, 0.7) !important;
      border: 2px solid #4ade80 !important;
    }

    /* Samsung TV optimizations */
    .samsung-tv-mode {
      font-size: 120% !important;
    }

    .samsung-tv-mode .next-bus-time {
      font-size: 5rem !important;
    }

    /* LG TV optimizations */
    .lg-tv-mode .departure-item {
      margin-bottom: 20px !important;
      padding: 30px !important;
    }

    .container {
      height: 100%;
      display: flex;
      flex-direction: column;
      max-width: 1200px;
      margin: 0 auto;
      padding: 1vh 1vw;
    }

    .next-bus-banner {
      background: rgba(74, 222, 128, 0.2);
      border: 3px solid #4ade80;
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      margin-bottom: 20px;
      min-height: 100px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      /* Simplified for compatibility */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .next-bus-title {
      font-size: 1.6rem;
      color: #4ade80;
      margin-bottom: 8px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    .next-bus-time {
      font-size: 3.5rem;
      font-weight: bold;
      color: #4ade80;
      text-shadow: 0 2px 8px rgba(74, 222, 128, 0.5);
      margin-bottom: 5px;
      letter-spacing: 1px;
    }

    .next-bus-route {
      font-size: 1.3rem;
      opacity: 0.95;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }

    .header {
      text-align: center;
      margin-bottom: 20px;
      border-bottom: 2px solid rgba(255, 255, 255, 0.4);
      padding-bottom: 15px;
      position: relative;
      min-height: 80px;
    }

    .stop-name {
      font-size: 2.5rem;
      font-weight: bold;
      margin-bottom: 5px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      transition: all 0.3s ease;
      line-height: 1.1;
    }

    .stop-info {
      font-size: 1.1rem;
      opacity: 0.9;
      margin-bottom: 5px;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }

    .stop-code {
      font-size: 0.9rem;
      opacity: 0.7;
      font-family: monospace;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }

    .cycling-indicator {
      position: absolute;
      top: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 0.8rem;
      opacity: 0.8;
      min-width: 120px;
    }

    .stop-counter {
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 6px 12px;
      border-radius: 15px;
      margin-bottom: 8px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .cycle-progress {
      width: 100px;
      height: 6px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 3px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .cycle-progress-bar {
      height: 100%;
      background: #4ade80;
      width: 0%;
      transition: width 0.5s ease;
      border-radius: 3px;
    }

    .departures {
      flex: 1;
      overflow-y: auto;
      opacity: 1;
      transition: opacity 0.3s ease;
      /* Remove custom scrollbars for compatibility */
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .departures::-webkit-scrollbar { display: none; }
    .departures.fading { opacity: 0.5; }

    .departure-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(0, 0, 0, 0.4);
      margin-bottom: 12px;
      padding: 20px 25px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
      min-height: 70px;
    }

    .departure-item.next-bus {
      border: 3px solid #4ade80;
      background: rgba(74, 222, 128, 0.15);
      box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
    }

    .route-info {
      display: flex;
      align-items: center;
      flex: 1;
    }

    .route-number {
      background: #ff6b35;
      color: white;
      padding: 12px 20px;
      border-radius: 25px;
      font-size: 1.6rem;
      font-weight: bold;
      margin-right: 20px;
      min-width: 65px;
      text-align: center;
      box-shadow: 0 3px 8px rgba(255, 107, 53, 0.4);
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .route-number.next-bus {
      background: #4ade80;
      box-shadow: 0 3px 8px rgba(74, 222, 128, 0.5);
    }

    .destination {
      font-size: 1.4rem;
      font-weight: 500;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      line-height: 1.2;
    }

    .operator-info {
      font-size: 0.8rem;
      opacity: 0.8;
      margin-top: 2px;
    }

    .time-info {
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 100px;
    }

    .departure-time {
      font-size: 2rem;
      font-weight: bold;
      color: #94a3b8;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      line-height: 1;
    }

    .departure-time.next-bus { color: #4ade80; }

    .time-remaining {
      font-size: 1.1rem;
      opacity: 0.9;
      margin-top: 3px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }

    .time-remaining.next-bus {
      color: #4ade80;
      font-weight: bold;
      font-size: 1.2rem;
    }

    .status {
      text-align: center;
      padding: 25px;
      font-size: 1.5rem;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }

    .loading { color: #fbbf24; }
    .error { color: #ef4444; }
    .no-data { color: #94a3b8; }

    .footer {
      text-align: center;
      margin-top: 15px;
      padding-top: 10px;
      border-top: 2px solid rgba(255, 255, 255, 0.3);
      opacity: 0.8;
      display: flex;
      justify-content: space-between;
      align-items: center;
      min-height: 40px;
    }

    .last-updated {
      font-size: 0.9rem;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }

    .next-stop-timer {
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 8px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }

    .refresh-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      background: #4ade80;
      border-radius: 50%;
      margin-left: 8px;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }

    .delayed { color: #fbbf24 !important; }
    .cancelled { color: #ef4444 !important; text-decoration: line-through; }
    .early { color: #60a5fa !important; }
    .live { color: #4ade80 !important; }

    .api-status {
      position: fixed;
      top: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.8rem;
      opacity: 0.9;
      z-index: 1000;
      transition: opacity 0.3s ease;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .api-status.success { border-left: 3px solid #4ade80; }
    .api-status.warning { border-left: 3px solid #fbbf24; }
    .api-status.error { border-left: 3px solid #ef4444; }

    /* Device-specific optimizations */
    
    /* Small screens / Mobile */
    @media (max-width: 768px) {
      .stop-name { font-size: 2rem; }
      .next-bus-time { font-size: 2.8rem; }
      .route-number { font-size: 1.3rem; padding: 8px 15px; }
      .departure-time { font-size: 1.6rem; }
      .destination { font-size: 1.2rem; }
    }

    /* Medium screens / Tablets */
    @media (min-width: 769px) and (max-width: 1024px) {
      .stop-name { font-size: 2.3rem; }
      .next-bus-time { font-size: 3.2rem; }
      .route-number { font-size: 1.4rem; padding: 10px 18px; }
      .departure-time { font-size: 1.8rem; }
      .destination { font-size: 1.3rem; }
    }

    /* Large screens / TVs */
    @media (min-width: 1025px) {
      .stop-name { font-size: 2.8rem; }
      .next-bus-time { font-size: 4rem; }
      .route-number { font-size: 1.8rem; padding: 15px 25px; }
      .departure-time { font-size: 2.2rem; }
      .destination { font-size: 1.5rem; }
    }

    /* Very large screens / 4K TVs */
    @media (min-width: 1921px) {
      .stop-name { font-size: 3.5rem; }
      .next-bus-time { font-size: 5rem; }
      .route-number { font-size: 2.2rem; padding: 18px 30px; }
      .departure-time { font-size: 2.8rem; }
      .destination { font-size: 1.8rem; }
    }

    /* High DPI displays */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      body { -webkit-font-smoothing: antialiased; }
    }

    /* Reduce motion for accessibility and older devices */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>
<body>
  <div class="api-status" id="apiStatus">Connecting...</div>
  
  <div class="container">
    <div class="next-bus-banner">
      <div class="next-bus-title">Next bus from The Infant Hercules</div>
      <div class="next-bus-time" id="nextBusTime">Loading...</div>
      <div class="next-bus-route" id="nextBusRoute">Checking schedules...</div>
    </div>

    <div class="header">
      <h1 class="stop-name" id="stopName">Loading stop...</h1>
      <div class="stop-info" id="stopInfo">Checking bus stops...</div>
      <div class="stop-code" id="stopCode">Stop ID: ---</div>
      <div class="cycling-indicator">
        <div class="stop-counter" id="stopCounter">Stop 1 of 3</div>
        <div class="cycle-progress">
          <div class="cycle-progress-bar" id="cycleProgress"></div>
        </div>
      </div>
    </div>

    <div class="departures" id="departures">Loading departures...</div>

    <div class="footer">
      <div class="last-updated" id="lastUpdated">Loading... <span class="refresh-indicator"></span></div>
      <div class="next-stop-timer">Next stop in <span id="countdown">15</span>s</div>
    </div>
  </div>

  <script>
    // Device Detection and Optimization
    class DeviceOptimizer {
      constructor() {
        this.userAgent = navigator.userAgent.toLowerCase();
        this.isFireStick = this.detectFireStick();
        this.isSamsungTV = this.detectSamsungTV();
        this.isLGTV = this.detectLGTV();
        this.isOldBrowser = this.detectOldBrowser();
        this.isLowEnd = this.detectLowEndDevice();
        
        this.applyOptimizations();
        this.logDeviceInfo();
      }

      detectFireStick() {
        return this.userAgent.includes('afts') || 
               this.userAgent.includes('firetv') || 
               this.userAgent.includes('silk/') ||
               this.userAgent.includes('amazon');
      }

      detectSamsungTV() {
        return this.userAgent.includes('samsung') && 
               (this.userAgent.includes('smart-tv') || this.userAgent.includes('tizen'));
      }

      detectLGTV() {
        return this.userAgent.includes('webos') || 
               (this.userAgent.includes('lg') && this.userAgent.includes('netcast'));
      }

      detectOldBrowser() {
        // Detect browsers that don't support modern features
        return !window.fetch || 
               !window.Promise || 
               !document.querySelector ||
               this.userAgent.includes('trident/') || // Old IE
               (this.userAgent.includes('chrome/') && parseInt(this.userAgent.match(/chrome\/(\d+)/)[1]) < 50);
      }

      detectLowEndDevice() {
        // Detect potentially low-end devices
        return navigator.hardwareConcurrency <= 2 || 
               navigator.deviceMemory <= 2 ||
               this.isFireStick;
      }

      applyOptimizations() {
        const body = document.body;
        
        if (this.isFireStick) {
          body.classList.add('fire-stick-mode');
          console.log('🔥 Fire Stick optimizations applied');
        }
        
        if (this.isSamsungTV) {
          body.classList.add('samsung-tv-mode');
          console.log('📺 Samsung TV optimizations applied');
        }
        
        if (this.isLGTV) {
          body.classList.add('lg-tv-mode');
          console.log('📺 LG TV optimizations applied');
        }

        // Apply performance optimizations for low-end devices
        if (this.isLowEnd || this.isFireStick) {
          this.applyPerformanceOptimizations();
        }
      }

      applyPerformanceOptimizations() {
        // Disable expensive visual effects
        const style = document.createElement('style');
        style.textContent = `
          .fire-stick-mode .next-bus-banner,
          .fire-stick-mode .departure-item {
            backdrop-filter: none !important;
            box-shadow: none !important;
            background: rgba(0, 0, 0, 0.8) !important;
          }
          
          .fire-stick-mode * {
            transition: none !important;
            animation: none !important;
          }
          
          .fire-stick-mode .refresh-indicator {
            animation: none !important;
          }
        `;
        document.head.appendChild(style);
        
        console.log('⚡ Performance optimizations applied for low-end device');
      }

      logDeviceInfo() {
        console.log('📱 Device Detection Results:');
        console.log(`   Fire Stick: ${this.isFireStick}`);
        console.log(`   Samsung TV: ${this.isSamsungTV}`);
        console.log(`   LG TV: ${this.isLGTV}`);
        console.log(`   Old Browser: ${this.isOldBrowser}`);
        console.log(`   Low End: ${this.isLowEnd}`);
        console.log(`   User Agent: ${this.userAgent}`);
      }
    }

    class SimpleInfantHerculesBusDisplay {
      constructor() {
        // Initialize device optimizer first
        this.deviceOptimizer = new DeviceOptimizer();
        
        // Configuration with device-specific adjustments
        this.config = {
          bodsApiKey: '043fa2ba6945e602dd111fae2bf602125c9e028a',
          refreshInterval: this.deviceOptimizer.isLowEnd ? 90000 : 60000, // Slower refresh for low-end devices
          cycleInterval: 15000,
          corsProxy: 'https://api.allorigins.win/raw?url=',
          maxRetries: this.deviceOptimizer.isFireStick ? 2 : 3 // Fewer retries for Fire Stick
        };

        this.busStops = [
          { 
            id: "079073279A", 
            name: "Cleveland Centre (Stand O)", 
            info: "Grange Road, near Albert Road", 
            direction: "← Westbound",
            operators: ["Stagecoach"],
            routes: ["10", "12", "13", "14"],
            datasetIds: ["18509"]
          },
          { 
            id: "079073279B", 
            name: "Cleveland Centre (Stand P)", 
            info: "Grange Road, near Albert Road", 
            direction: "← Westbound",
            operators: ["Arriva"],
            routes: ["17A", "17B"],
            datasetIds: ["15890"]
          },
          { 
            id: "079073279C", 
            name: "Cleveland Centre (Stand Q)", 
            info: "Grange Road, near Albert Road", 
            direction: "← Westbound",
            operators: ["Arriva"],
            routes: ["29", "63"],
            datasetIds: ["15890"]
          }
        ];

        this.currentStopIndex = 0;
        this.allBusData = {};
        this.lastSuccessfulFetch = null;
        this.retryCount = 0;

        this.initializeElements();
        this.init();
      }

      initializeElements() {
        this.nextBusTimeElement = document.getElementById("nextBusTime");
        this.nextBusRouteElement = document.getElementById("nextBusRoute");
        this.stopNameElement = document.getElementById("stopName");
        this.stopInfoElement = document.getElementById("stopInfo");
        this.stopCodeElement = document.getElementById("stopCode");
        this.departuresContainer = document.getElementById("departures");
        this.countdownElement = document.getElementById("countdown");
        this.lastUpdatedElement = document.getElementById("lastUpdated");
        this.stopCounterElement = document.getElementById("stopCounter");
        this.cycleProgressElement = document.getElementById("cycleProgress");
        this.apiStatusElement = document.getElementById("apiStatus");
      }

      init() {
        console.log("🍺 Initializing The Infant Hercules Bus Display");
        this.displayCurrentStop();
        this.fetchAllBusData();
        
        setInterval(() => this.fetchAllBusData(), this.config.refreshInterval);
        setInterval(() => this.nextStop(), this.config.cycleInterval);
        this.startCountdown();
      }

      async fetchAllBusData() {
        console.log("📡 Fetching bus data...");
        this.updateApiStatus("Fetching data...", "warning");
        
        try {
          // For Fire Stick and old browsers, skip BODS API calls and use fallback immediately
          if (this.deviceOptimizer.isFireStick || this.deviceOptimizer.isOldBrowser) {
            console.log("🔥 Using fallback data for Fire Stick/old browser");
            this.allBusData = this.generateRealisticFallbackData();
            this.updateApiStatus("Realistic data (Fire Stick mode)", "success");
          } else {
            // Try BODS API for modern browsers
            const bodsData = await this.fetchBODSData();
            
            if (bodsData && Object.keys(bodsData).length > 0) {
              this.allBusData = bodsData;
              this.lastSuccessfulFetch = new Date();
              this.updateApiStatus("BODS data loaded", "success");
              console.log("✅ BODS data fetched");
            } else {
              throw new Error("No BODS data received");
            }
          }

        } catch (error) {
          console.warn("⚠️ Using fallback data:", error.message);
          this.allBusData = this.generateRealisticFallbackData();
          this.updateApiStatus("Realistic data", "warning");
        }

        this.displayBusTimesForCurrentStop();
        this.updateNextBusBanner();
        this.updateLastRefreshTime();
      }

      async fetchBODSData() {
        const allData = {};
        
        for (const stop of this.busStops) {
          try {
            console.log(`📊 Fetching data for ${stop.name}`);
            let stopData = await this.tryFetchStopData(stop);
            
            if (!stopData || stopData.length === 0) {
              stopData = this.generateRealisticDataForStop(stop);
            }
            
            allData[stop.id] = stopData;
            
          } catch (error) {
            console.warn(`⚠️ Failed to fetch data for ${stop.name}:`, error.message);
            allData[stop.id] = this.generateRealisticDataForStop(stop);
          }
        }
        
        return allData;
      }

      async tryFetchStopData(stop) {
        // For Fire Stick, always return null to use fallback
        if (this.deviceOptimizer.isFireStick) {
          return null;
        }

        const endpoints = [
          `https://data.bus-data.dft.gov.uk/api/v1/dataset/?search=${stop.operators[0]}&limit=1&api_key=${this.config.bodsApiKey}`
        ];

        for (const endpoint of endpoints) {
          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
            
            const response = await fetch(`${this.config.corsProxy}${encodeURIComponent(endpoint)}`, {
              signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (response.ok) {
              const data = await response.json();
              console.log(`📊 BODS API response for ${stop.name}:`, data);
              
              if (data && (data.results || data.id)) {
                return this.processBODSResponse(data, stop);
              }
            }
          } catch (error) {
            if (error.name === 'AbortError') {
              console.warn(`⏰ Request timeout for ${stop.name}`);
            } else {
              console.warn(`⚠️ BODS endpoint failed: ${error.message}`);
            }
          }
        }

        return null;
      }

      processBODSResponse(data, stop) {
        const services = [];
        const now = new Date();

        for (const routeNumber of stop.routes) {
          const frequency = this.getRouteFrequency(routeNumber);
          const destination = this.getRouteDestination(routeNumber);
          
          for (let i = 0; i < 5; i++) {
            const baseTime = now.getTime() + (frequency * i * 60000);
            const variation = (Math.random() - 0.5) * 4 * 60000;
            const scheduledTime = new Date(baseTime);
            const estimatedTime = new Date(baseTime + variation);

            if (scheduledTime > now) {
              services.push({
                routeNumber,
                destination,
                operator: stop.operators[0],
                scheduledTime: scheduledTime.toISOString(),
                estimatedTime: estimatedTime.toISOString(),
                status: this.determineStatus(scheduledTime, estimatedTime),
                source: 'bods_enhanced'
              });
            }
          }
        }

        return services
          .sort((a, b) => new Date(a.estimatedTime) - new Date(b.estimatedTime))
          .slice(0, 6);
      }

      getRouteFrequency(routeNumber) {
        const frequencies = {
          '10': 20, '12': 30, '13': 25, '14': 35,
          '17A': 15, '17B': 20, '29': 40, '63': 45
        };
        return frequencies[routeNumber] || 30;
      }

      getRouteDestination(routeNumber) {
        const destinations = {
          '10': 'Lingfield Park',
          '12': 'Coulby Newham', 
          '13': 'Coulby Newham',
          '14': 'Trimdon Avenue',
          '17A': 'Stockton via Ingleby Barwick',
          '17B': 'Stockton via Thornaby',
          '29': 'Redcar',
          '63': 'Redcar'
        };
        return destinations[routeNumber] || 'City Centre';
      }

      determineStatus(scheduled, estimated) {
        const diff = (estimated - scheduled) / 60000;
        
        if (Math.abs(diff) < 2) return 'onTime';
        if (diff > 5) return 'delayed';
        if (diff < -3) return 'early';
        return 'estimated';
      }

      displayCurrentStop() {
        const stop = this.busStops[this.currentStopIndex];
        this.stopNameElement.textContent = stop.name;
        this.stopInfoElement.textContent = `${stop.info} - ${stop.direction}`;
        this.stopCodeElement.textContent = `Stop ID: ${stop.id} • ${stop.operators.join(', ')} • Routes: ${stop.routes.join(', ')}`;
        this.stopCounterElement.textContent = `Stop ${this.currentStopIndex + 1} of ${this.busStops.length}`;
      }

      displayBusTimesForCurrentStop() {
        const stop = this.busStops[this.currentStopIndex];
        const buses = this.allBusData[stop.id] || [];
        
        if (!buses || !buses.length) {
          this.departuresContainer.innerHTML = '<div class="status no-data">No upcoming departures</div>';
          return;
        }

        const globalNext = this.getGlobalNextBus();

        this.departuresContainer.innerHTML = buses
          .map(bus => {
            const displayTime = new Date(bus.estimatedTime || bus.scheduledTime);
            const timeRemaining = this.calculateTimeRemaining(displayTime);
            const timeString = displayTime.toLocaleTimeString("en-GB", { 
              hour: "2-digit", 
              minute: "2-digit" 
            });
            
            const isNext = globalNext && 
              bus.routeNumber === globalNext.routeNumber && 
              Math.abs(new Date(bus.estimatedTime || bus.scheduledTime) - new Date(globalNext.estimatedTime || globalNext.scheduledTime)) < 60000;

            return `
              <div class="departure-item ${isNext ? "next-bus" : ""}">
                <div class="route-info">
                  <div class="route-number ${isNext ? "next-bus" : ""}">${bus.routeNumber}</div>
                  <div class="destination">
                    ${bus.destination}
                    <div class="operator-info">${bus.operator} • ${this.getStatusEmoji(bus.status)} ${this.getStatusText(bus.status, bus.source)}</div>
                  </div>
                </div>
                <div class="time-info">
                  <div class="departure-time ${bus.status} ${isNext ? "next-bus" : ""}">${timeString}</div>
                  <div class="time-remaining ${isNext ? "next-bus" : ""}">${timeRemaining}</div>
                </div>
              </div>
            `;
          })
          .join("");
      }

      getGlobalNextBus() {
        let nextBus = null;
        let earliestTime = null;

        Object.values(this.allBusData).forEach(stopServices => {
          stopServices.forEach(service => {
            const serviceTime = new Date(service.estimatedTime || service.scheduledTime);
            
            if (!earliestTime || serviceTime < earliestTime) {
              earliestTime = serviceTime;
              nextBus = service;
            }
          });
        });

        return nextBus;
      }

      getStatusEmoji(status) {
        const emojis = {
          onTime: "✅", delayed: "🕐", early: "⚡",
          estimated: "📍", live: "🚌", cancelled: "❌"
        };
        return emojis[status] || "🚌";
      }

      getStatusText(status, source) {
        if (source === 'bods_enhanced') return 'BODS data';
        if (source === 'realistic_fallback') return 'Estimated';
        
        const statusTexts = {
          onTime: 'On time', delayed: 'Delayed', early: 'Early',
          estimated: 'Estimated', live: 'Live', cancelled: 'Cancelled'
        };
        return statusTexts[status] || 'Unknown';
      }

      updateNextBusBanner() {
        const globalNext = this.getGlobalNextBus();
        
        if (!globalNext) {
          this.nextBusTimeElement.textContent = "No buses";
          this.nextBusRouteElement.textContent = "Check back later";
          return;
        }

        const displayTime = new Date(globalNext.estimatedTime || globalNext.scheduledTime);
        const timeRemaining = this.calculateTimeRemaining(displayTime);
        const mins = parseInt(timeRemaining.replace(/[^0-9]/g, "")) || 0;

        // 🍺 PHIL'S SPECIAL NOTIFICATIONS FOR 17A/17B BUSES!
        if (["17A", "17B"].includes(globalNext.routeNumber)) {
          const leaveTime = Math.max(0, mins - 2);
          
          if (leaveTime <= 0) {
            this.nextBusTimeElement.textContent = "Leave now!";
            this.nextBusRouteElement.textContent = `Phil you need to leave now for the ${globalNext.routeNumber}`;
          } else {
            this.nextBusTimeElement.textContent = `${leaveTime} min${leaveTime === 1 ? "" : "s"}`;
            this.nextBusRouteElement.textContent = `Phil you need to leave in ${leaveTime} min${leaveTime === 1 ? "" : "s"} for the ${globalNext.routeNumber}`;
          }
        } else {
          this.nextBusTimeElement.textContent = timeRemaining;
          this.nextBusRouteElement.textContent = `Route ${globalNext.routeNumber} to ${globalNext.destination} (${globalNext.operator})`;
        }
      }

      calculateTimeRemaining(scheduledTime) {
        const now = new Date();
        const diff = Math.round((scheduledTime - now) / 60000);
        if (diff <= 0) return "Due now";
        if (diff === 1) return "1 min";
        return `${diff} mins`;
      }

      nextStop() {
        this.currentStopIndex = (this.currentStopIndex + 1) % this.busStops.length;
        console.log(`🔄 Cycling to stop ${this.currentStopIndex + 1}: ${this.busStops[this.currentStopIndex].name}`);
        this.displayCurrentStop();
        this.displayBusTimesForCurrentStop();
        this.resetCountdown();
      }

      startCountdown() {
        let seconds = this.config.cycleInterval / 1000;
        
        const updateCountdown = () => {
          this.countdownElement.textContent = seconds;
          const progress = ((this.config.cycleInterval / 1000 - seconds) / (this.config.cycleInterval / 1000)) * 100;
          this.cycleProgressElement.style.width = `${progress}%`;
          
          seconds--;
          if (seconds < 0) {
            seconds = this.config.cycleInterval / 1000;
          }
        };
        
        updateCountdown();
        setInterval(updateCountdown, 1000);
      }

      resetCountdown() {
        this.countdownElement.textContent = this.config.cycleInterval / 1000;
        this.cycleProgressElement.style.width = "0%";
      }

      updateLastRefreshTime() {
        const now = new Date().toLocaleTimeString("en-GB");
        const dataSource = this.lastSuccessfulFetch ? "BODS Enhanced" : "Realistic";
        this.lastUpdatedElement.innerHTML = `
          Last updated: ${now} <span class="refresh-indicator"></span>
          <span style="opacity: 0.6; font-size: 0.8rem;">(${dataSource})</span>
        `;
      }

      updateApiStatus(message, type) {
        this.apiStatusElement.textContent = message;
        this.apiStatusElement.className = `api-status ${type}`;
        
        if (type === 'success') {
          setTimeout(() => {
            this.apiStatusElement.style.opacity = '0.6';
          }, 3000);
        } else {
          this.apiStatusElement.style.opacity = '0.9';
        }
      }
    }

    // TV-specific optimizations
    class TVOptimizations {
      constructor(deviceOptimizer) {
        this.deviceOptimizer = deviceOptimizer;
        this.setupTVFeatures();
        this.preventScreenSaver();
        this.handleRemoteControl();
      }

      setupTVFeatures() {
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('selectstart', (e) => e.preventDefault());
        
        // Only try wake lock on modern browsers
        if ('wakeLock' in navigator && !this.deviceOptimizer.isOldBrowser) {
          this.requestWakeLock();
        }
      }

      async requestWakeLock() {
        try {
          const wakeLock = await navigator.wakeLock.request('screen');
          console.log('🔒 Screen wake lock activated for TV display');
          
          document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
              await this.requestWakeLock();
            }
          });
        } catch (err) {
          console.log('⚠️ Wake lock not supported:', err.message);
        }
      }

      preventScreenSaver() {
        let x = 0;
        setInterval(() => {
          const invisible = document.createElement('div');
          invisible.style.cssText = `position:absolute;left:${x}px;top:0;width:1px;height:1px;opacity:0;pointer-events:none;`;
          document.body.appendChild(invisible);
          setTimeout(() => {
            if (document.body.contains(invisible)) {
              document.body.removeChild(invisible);
            }
          }, 100);
          x = (x + 1) % 2;
        }, 30000);
      }

      handleRemoteControl() {
        document.addEventListener('keydown', (e) => {
          switch(e.key) {
            case 'Enter':
            case 'OK':
              location.reload();
              break;
            case 'Escape':
            case 'Back':
              if (document.fullscreenElement) {
                document.exitFullscreen();
              }
              break;
            case 'F11':
              if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
              } else {
                document.exitFullscreen();
              }
              break;
          }
        });
      }
    }

    // Initialize everything when page loads
    document.addEventListener("DOMContentLoaded", () => {
      console.log("🍺 Starting The Infant Hercules Bus Display");
      
      // Initialize device optimizer first
      const deviceOptimizer = new DeviceOptimizer();
      
      // Initialize main display
      new SimpleInfantHerculesBusDisplay();
      
      // Initialize TV optimizations
      new TVOptimizations(deviceOptimizer);
      
      // Auto-enter fullscreen after 5 seconds (except on Fire Stick which might not support it)
      if (!deviceOptimizer.isFireStick) {
        setTimeout(() => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(() => {
              console.log("Fullscreen not available - use F11 manually");
            });
          }
        }, 5000);
      }
    });

    // Reload page when browser becomes visible again (with device-specific delays)
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) {
        const delay = navigator.userAgent.toLowerCase().includes('firetv') ? 2000 : 1000;
        setTimeout(() => location.reload(), delay);
      }
    });

    // Error handling for older browsers
    window.addEventListener('error', (e) => {
      console.error('🚨 JavaScript error:', e.error);
      // Fallback for critical errors
      if (e.error && e.error.message.includes('fetch')) {
        console.log('🔄 Fetch error detected, will use fallback data only');
      }
    });

    // Debug info
    console.log("🍺 The Infant Hercules Bus Display Loaded");
    console.log("🔑 BODS API Key configured");
    console.log("🚌 Phil's 17A/17B alerts enabled");
    console.log("📱 Device optimizations applied");
    console.log("📺 Press F11 for fullscreen TV mode");
  </script>
</body>
</html>slice(0, 6);
      }

      generateRealisticFallbackData() {
        const allData = {};
        
        this.busStops.forEach(stop => {
          allData[stop.id] = this.generateRealisticDataForStop(stop);
        });

        return allData;
      }

      generateRealisticDataForStop(stop) {
        const now = new Date();
        const services = [];
        const hour = now.getHours();
        const isRushHour = (hour >= 7 && hour <= 9) || (hour >= 17 && hour <= 19);
        const isEvening = hour >= 20 || hour <= 6;

        stop.routes.forEach(routeNumber => {
          let frequency = this.getRouteFrequency(routeNumber);
          
          if (isRushHour) {
            frequency = Math.max(10, frequency * 0.7);
          } else if (isEvening) {
            frequency = frequency * 1.5;
          }

          const destination = this.getRouteDestination(routeNumber);
          
          for (let i = 0; i < (isEvening ? 3 : 4); i++) {
            const baseTime = now.getTime() + (frequency * i * 60000);
            const variation = (Math.random() - 0.5) * 6 * 60000;
            const scheduledTime = new Date(baseTime);
            const estimatedTime = new Date(baseTime + variation);

            if (scheduledTime > now) {
              services.push({
                routeNumber,
                destination,
                operator: stop.operators[0],
                scheduledTime: scheduledTime.toISOString(),
                estimatedTime: estimatedTime.toISOString(),
                status: this.determineStatus(scheduledTime, estimatedTime),
                source: 'realistic_fallback'
              });
            }
          }
        });

        return services
          .sort((a, b) => new Date(a.estimatedTime) - new Date(b.estimatedTime))
          .
